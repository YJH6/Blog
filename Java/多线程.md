# 多线程

## 概述

* JVM与多线程

  Java编写的程序都运行在Java虚拟机（JVM）中，在JVM的内部，程序的多任务是通过线程来实现的

  每用java命令启动一个java应用程序，就会启动一个JVM进程。在同一个JVM进程中，有且只有一个进程，就是它自己。在这个JVM环境中，所有程序代码的运行都是以线程来运行的。JVM找到程序的入口点main()，然后运行main()方法，这样就产生了一个线程，这个线程称之为主线程。当main方法结束后，主线程运行完成。JVM进程也随即退出

  操作系统将进程线程进行管理，轮流（没有固定的顺序）分配每个进程很短的一段时间（不一定是均分），然后在每个进程内部，程序代码自己处理该进程内部线程的时间分配，多个线程之间相互的切换去执行，这个切换时间也是非常短的

* 线程的状态切换

  由于线程何时执行是未知的，只有在CPU为线程分配到时间片时，线程才能真正执行。在线程执行的过程中，由可能会因为各种各样的原因而暂停

  这样线程就有了“状态”的概念


## 实现

* 在实现线程编程时，首先需要让一个类具备多线程的能力，继承Thread类或实现Runnable接口的类具备多线程的能力，然后创建线程对象，调用对应的启动线程方法即可实现线程编程

  在一个程序中可以实现多个线程，多线程编程指在同一个程序中启动了两个或两个以上的线程。

  在实际实现线程时，Java语言提供了三种实现方式：

  （1）继承Thread类

  （2）实现Runnable接口

  （3）使用Timer和TimerTask组合

* 继承Thread线程类实现多线程
  java.lang包中提供了一个专门的线程类（Thread），在该类中封装了许多对线程进行调度和处理的方法。如果一个类继承了Thread类，则该类就具备了多线程的能力，可以多线程的方式执行。

```java
`class` `MyThread ``extends` `Thread{`` ` `public` `void` `run(){`` ` `//线程体`` ` `}`` ` `}`` ` `继承Thread类实现多线程。`` ` `MyThread tt1 = ``new` `MyThread ();`` ` `//启动线程`` ` `tt1.start();`` ` `try``{`` ` `for``(``int` `i = ``0``;i < ``5``;i++){`` ` `//延时1秒`` ` `Thread.sleep(``1000``);`` ` `System.out.println(``"Main:"` `+ i);`` ` `}`` ` `}``catch``(Exception e){}`
```

* 注意：

  * 线程的特性：随机性，系统在执行多线程程序时只保证线程是交替执行的，至于哪个线程先执行哪个线程后执行，则无法获得保证，需要书写专门的代码才可以保证执行的顺序。

  * 对于同一个线程类，也可以启动多个线程

  * 同一个线程不能启动两次，
  * 当自定义线程中的run方法执行完成以后，则自定义线程自然死亡。而对于系统线程来说，只有当main方法执行结束，而且启动的其它线程都结束以后，才会结束。当系统线程执行结束以后，程序的执行才真正结束。

* 实现Runable接口
  * 多线程对象实现java.lang.Runnable接口并且在该类中重写Runnable接口的run方法。
  * 好处：实现Runable接口的方法避免了单继承的局限性。

使用实现Runable接口的方式实现多线程。

```java
`class` `MyThread2 ``implements` `Runable{`` ` `public` `void` `run(){} ``//重写Runable接口中的run()方法`` ` `}`` ` `MyThread2 mt1=``new` `MyThread2();`` ` `Thread t1=``new` `Thread(mt1);`` ` `t1.start();`
```

## 线程的生命周期

* 线程的生命周期

  线程是一个动态执行的过程，它也有一个从产生到死亡的过程，这就是所谓的生命周期。一个线程在它的生命周期内有5种状态：

  * 新建（new Thread）

    当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。
    例如：Thread t1=new Thread();

  * 就绪（runnable）

    线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();

  * 运行（running）

    线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。

  * 死亡（dead）

    当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。

    自然终止：正常运行run()方法后终止

    异常终止：调用stop()方法让一个线程终止运行

  * 堵塞（blocked）

    由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。

    正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。

    正在等待：调用wait()方法。（调用motify()方法回到就绪状态）

    被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）